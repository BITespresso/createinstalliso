#!/bin/bash

# createinstalliso - Creates a bootable ISO image from a Mac OS X
# installer application.
# Copyright (C) 2017 Michael Berger <michael.berger@gmx.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

if ! [ -n "${BASH}" ]; then
	echo "This tool must be run in Bash shell." 1>&2
	exit 1
fi

declare -r const_script_name="createinstalliso"
declare -r -i const_root_uid="0"

# This script requires /usr/libexec/PlistBuddy to read values from
# property list files. PlistBuddy is available on Mac OS X 10.5 Leopard
# or later. However on Mac OS X 10.5 Leopard PlistBuddy does not handle
# large integer values correctly. Therefore, this script requires
# Mac OS X 10.6 Snow Leopard or later.
declare -r -a const_unsupported_mac_os_x_major_versions=(
	"10.0"  # Mac OS X Cheetah
	"10.1"  # Mac OS X Puma
	"10.2"  # Mac OS X Jaguar
	"10.3"  # Mac OS X Panther
	"10.4"  # Mac OS X Tiger
	"10.5"  # Mac OS X Leopard
)

# This script has been tested on the following Mac OS X major versions.
declare -r -a const_supported_mac_os_x_major_versions=(
	"10.6"  # Mac OS X Snow Leopard
	"10.7"  # Mac OS X Lion
	"10.8"  # OS X Mountain Lion
	"10.9"  # OS X Mavericks
	"10.10" # OS X Yosemite
	"10.11" # OS X El Capitan
	"10.12" # macOS Sierra
)

# This script has been tested with the following installer applications.
declare -r -a const_supported_installer_application_display_names=(
	"Install Mac OS X Lion"      # 10.7
	"Install OS X Mountain Lion" # 10.8
	"Install OS X Mavericks"     # 10.9
	"Install OS X Yosemite"      # 10.10
	"Install OS X El Capitan"    # 10.11
	"Install macOS Sierra"       # 10.12
)

unset global_exit_message
unset global_tmp_directory
unset global_install_esd_dmg_mountpoint
unset global_writable_installer_disk_image_mountpoint
unset global_incomplete_iso_destination_file
declare -i global_exit_with_error_exit_status="1"

# ======================================================================
# Helper functions
# ======================================================================

exit_handler() {
	trap - EXIT
	cleanup

	if is_not_empty "${global_exit_message-}"; then
		echo "${global_exit_message}"
		unset global_exit_message
	fi
}

signal_handler() {
	local -r -i exit_status="$?"

	trap - EXIT
	cleanup

	unset global_exit_message
	exit "${exit_status}"
}

cleanup() {
	if is_not_empty "${global_tmp_directory-}" && is_existing "${global_tmp_directory}"; then
		if is_not_empty "${global_writable_installer_disk_image_mountpoint-}" && is_existing "${global_writable_installer_disk_image_mountpoint}"; then
			hdiutil detach "${global_writable_installer_disk_image_mountpoint}" -force &> /dev/null && unset global_writable_installer_disk_image_mountpoint
		fi
		if is_not_empty "${global_install_esd_dmg_mountpoint-}" && is_existing "${global_install_esd_dmg_mountpoint}"; then
			hdiutil detach "${global_install_esd_dmg_mountpoint}" -force &> /dev/null && unset global_install_esd_dmg_mountpoint
		fi

	    rm -rf "${global_tmp_directory}" &> /dev/null && unset global_tmp_directory
	fi

	# Remove the incomplete destination file if the user interrupts the
	# script while creating the final ISO file.
	if is_not_empty "${global_incomplete_iso_destination_file-}" && is_existing "${global_incomplete_iso_destination_file}"; then
		rm -rf "${global_incomplete_iso_destination_file}" &> /dev/null && unset global_incomplete_iso_destination_file
	fi
	return 0
}

echo_warning() {
	echo -n "+++ WARNING: " 1>&2
	echo "$@" 1>&2
	return 0
}

echo_error() {
	echo "$@" 1>&2
	return 0
}

echo_error_usage() {
	cat <<-EOF 1>&2
	Usage: ${const_script_name} --destinationpath <path to destination directory> --applicationpath <path to OS installer application> [--genuine] [--nointeraction]

	Arguments--destinationpath, A path to a directory where the installer ISO image will be created.
	--applicationpath, A path to copy of the OS installer application to create the bootable ISO image from.
	--genuine, Create an ISO image that is most close to Apple's Install DVD, but potentially less compatible with some BIOS/UEFI.
	--nointeraction, Delete an existing file (or directory) in the destination directory when it has the same name as the target ISO file without prompting for confirmation.

	Example: ${const_script_name} --destinationpath ~/Desktop --applicationpath "/Applications/$(get_example_installer_application_name)"
EOF
	if ! is_root; then
		echo_error
		echo_error "This tool must be run as root."
	fi
	return 0
}

is_empty() {
	local -r string="$1"

	[[ -z "${string}" ]]
}

is_not_empty() {
	local -r string="$1"

	[[ -n "${string}" ]]
}

is_existing() {
	local -r file_or_directory="$1"

	[[ -e "${file_or_directory}" ]]
}

is_file() {
	local -r file_or_directory="$1"

	[[ -f "${file_or_directory}" ]]
}

is_directory() {
	local -r file_or_directory="$1"

	[[ -d "${file_or_directory}" ]]
}

is_root() {
	[[ "$(id -u)" -eq "${const_root_uid}" ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is an option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_option_including_option_parameter() {
	local -r argument="$1"

	is_long_option_including_option_parameter "${argument}" || is_short_option_including_option_parameter "${argument}"
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == --*=* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a short option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option() {
	local -r argument="$1"

	[[ "${argument}" == --?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a valid abbreviation for a given long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
# $2 - long option (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_valid_long_option() {
	local -r argument="$1"
	local -r long_option="$2"

	is_long_option "${argument}" || return 1

	[[ "${long_option}" == "${argument}"* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a combination of multiple short options.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_options_combination() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

is_valid_destination_directory_path() {
	local -r destination_directory_path="$1"

	is_not_empty "${destination_directory_path}" || return 1

	is_directory "${destination_directory_path}"
}

is_valid_installer_application_path() {
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	is_file "${installer_application_path}/Contents/SharedSupport/InstallESD.dmg"
}

# ----------------------------------------------------------------------
# Checks if an operating system is Mac OS X.
#
# Input:
# $1 - operating system name
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_mac_os_x() {
	local -r os_name="$1"

	is_not_empty "${os_name}" || return 1

	[[ "${os_name}" == "Darwin" ]]
}

is_valid_mac_os_x_version() {
	local -r mac_os_x_version="$1"
	local -r valid_mac_os_x_version_regex='^10\.[[:digit:]]+(\.[[:digit:]]+)?$'

	[[ "${mac_os_x_version}" =~ ${valid_mac_os_x_version_regex} ]]
}

is_unsupported_mac_os_x_major_version() {
	local -r mac_os_x_major_version="$1"

	is_array_item "${mac_os_x_major_version}" "const_unsupported_mac_os_x_major_versions"
}

is_supported_mac_os_x_major_version() {
	local -r mac_os_x_major_version="$1"

	is_array_item "${mac_os_x_major_version}" "const_supported_mac_os_x_major_versions"
}

is_supported_installer_application_display_name() {
	local -r installer_application_display_name="$1"

	is_array_item "${installer_application_display_name}" "const_supported_installer_application_display_names"
}

# ----------------------------------------------------------------------
# Checks if an item is contained in an array. The array is passed to the
# function by reference via its name.
#
# Input:
# $1 - item
# $2 - name of the array as string
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_array_item() {
	local -r item="$1"
	local -r array_name="$2[@]"
	local current_item

	for current_item in "${!array_name}"; do
		if [[ "${current_item}" == "${item}" ]]; then
			return 0
		fi
	done
	return 1
}

# ----------------------------------------------------------------------
# Executes a PlistBuddy command on a property list file.
#
# Input:
# $1 - command to be executed by PlistBuddy
# $2 - property list file
#
# Output:
# output of PlistBuddy
# ----------------------------------------------------------------------
execute_plist_buddy_command() {
	local -r plist_command="$1"
	local -r plist_file="$2"

	is_not_empty "${plist_command}" || return 1
	is_not_empty "${plist_file}" || return 1

	/usr/libexec/PlistBuddy -c "${plist_command}" "${plist_file}" 2> /dev/null
}

# ----------------------------------------------------------------------
# Returns the name of the running operating system.
#
# Output:
# operating system name
# ----------------------------------------------------------------------
get_os_name() {
	local os_name

	os_name="$(uname -s 2> /dev/null)" || return 1

	echo "${os_name}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the major version of the running Mac OS X operating system.
#
# Output:
# Mac OS X major version
# ----------------------------------------------------------------------
get_mac_os_x_major_version() {
	local mac_os_x_version
	local mac_os_x_major_version

	mac_os_x_version="$(sw_vers -productVersion 2> /dev/null)" || return 1
	is_valid_mac_os_x_version "${mac_os_x_version}" || return 1

	mac_os_x_major_version="$(get_mac_os_x_major_version_from_mac_os_x_version "${mac_os_x_version}")" || return 1

	echo "${mac_os_x_major_version}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the major version part of a Mac OS X version number. Example:
# The major version part of the version number '10.12.6' is '10.12'.
#
# Input:
# $1 - Mac OS X version number
#
# Output:
# major version part of the Mac OS X version number
# ----------------------------------------------------------------------
get_mac_os_x_major_version_from_mac_os_x_version() {
	local -r mac_os_x_version="$1"
	local mac_os_x_major_version
	local -r valid_mac_os_x_major_version_regex='^10\.[[:digit:]]+$'

	is_valid_mac_os_x_version "${mac_os_x_version}" || return 1

	if [[ "${mac_os_x_version}" =~ ${valid_mac_os_x_major_version_regex} ]]; then
		mac_os_x_major_version="${mac_os_x_version}"
	else
		mac_os_x_major_version="${mac_os_x_version%.*}"
	fi

	echo "${mac_os_x_major_version}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the value of an entry in a property list file.
#
# Input:
# $1 - entry
# $2 - property list file
#
# Output:
# value of the specified entry
# ----------------------------------------------------------------------
get_plist_value() {
	local -r entry="$1"
	local -r plist_file="$2"

	is_not_empty "${entry}" || return 1
	is_not_empty "${plist_file}" || return 1

	execute_plist_buddy_command "Print '${entry}'" "${plist_file}"
}

# ----------------------------------------------------------------------
# Returns the display name of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# display name of the installer application
# ----------------------------------------------------------------------
get_installer_application_display_name() {
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleDisplayName" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the URL of the system image within an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# URL of the system image
# ----------------------------------------------------------------------
get_system_image_url()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":System Image Info:URL" "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"
}

# ----------------------------------------------------------------------
# Returns the total number of bytes in a disk image.
#
# Input:
# $1 - disk image file
# global_tmp_directory - temporary directory
#
# Output:
# total number of bytes in the disk image
# ----------------------------------------------------------------------
get_disk_image_total_bytes() {
	local -r disk_image_file="$1"
	local plist_file

	is_not_empty "${disk_image_file}" || return 1
	is_not_empty "${global_tmp_directory-}" || return 1

	plist_file="${disk_image_file##*/}"
	plist_file="${global_tmp_directory}/${plist_file%.*}ImageInfo.plist"
	hdiutil imageinfo "${disk_image_file}" -plist > "${plist_file}" 2> /dev/null || return 1

	get_plist_value ":Size Information:Total Bytes" "${plist_file}"
}

# ----------------------------------------------------------------------
# Returns the total number of non empty bytes in a disk image.
#
# Input:
# $1 - disk image file
# global_tmp_directory - temporary directory
#
# Output:
# total number of non empty bytes in the disk image
# ----------------------------------------------------------------------
get_disk_image_total_non_empty_bytes() {
	local -r disk_image_file="$1"
	local plist_file

	is_not_empty "${disk_image_file}" || return 1
	is_not_empty "${global_tmp_directory-}" || return 1

	plist_file="${disk_image_file##*/}"
	plist_file="${global_tmp_directory}/${plist_file%.*}ImageInfo.plist"
	hdiutil imageinfo "${disk_image_file}" -plist > "${plist_file}" 2> /dev/null || return 1

	get_plist_value ":Size Information:Total Non-Empty Bytes" "${plist_file}"
}

# ----------------------------------------------------------------------
# Returns the absolute logical path to a file or directory.
#
# Input:
# $1 - absolute or relative path to a file or directory
#
# Output:
# absolute logical (i.e. not the physical) path to the file or directory
# ----------------------------------------------------------------------
get_absolute_logical_path() {
	local -r file_or_directory="$1"

	is_not_empty "${file_or_directory}" || return 1
	is_existing "${file_or_directory}" || return 1

	if is_directory "${file_or_directory}"; then
		echo "$(cd "${file_or_directory}"; pwd -L)"
	else
		if [[ "${file_or_directory}" == */* ]]; then
			echo "$(cd "${file_or_directory%/*}"; pwd -L)/${file_or_directory##*/}"
		else
			echo "$(pwd -L)/${file_or_directory}"
		fi
	fi
	return 0
}

# ----------------------------------------------------------------------
# Asks the user for consent on the command line. Any user input starting
# with 'y' or 'Y' will be treated as consent.
#
# Input:
# $1 - prompt to be displayed on the command line
#
# Output:
# none - returns with exit status zero if user gave his consent
# ----------------------------------------------------------------------
get_user_consent() {
	local -r prompt="$1"
	local input
	local -r yes_regex='^[yY].*$'

	echo -n "${prompt}"
	input="$(IFS=""; read -r input; echo "${input}")"

	[[ "${input}" =~ ${yes_regex} ]]
}

get_example_installer_application_name() {
	local -r -i number_of_elements="${#const_supported_installer_application_display_names[@]}"
	local example_installer_application_name="${const_supported_installer_application_display_names[${number_of_elements}-1]}.app"
	local -i i

	for (( i = number_of_elements - 1; i >= 0; i-- )); do
		if is_valid_installer_application_path "/Applications/${const_supported_installer_application_display_names[${i}]}.app"; then
			example_installer_application_name="${const_supported_installer_application_display_names[${i}]}.app"
			break
		fi
	done

	echo "${example_installer_application_name}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the type of an installer application. The type is determined
# by checking the presence of some files that are specific to the
# different installer types.
#
# The returned types are:
#
# '0' - Installer application type unknown
# '1' - Installer application type for Mac OS X 10.7 to 10.8
# '2' - Installer application type for Mac OS X 10.9 to 10.11
# '3' - Installer application type for Mac OS X 10.12 to 10.13
#
# Input:
# $1 - path to the installer application
#
# Output:
# type of the installer application
# ----------------------------------------------------------------------
get_installer_application_type()
{
	local -r installer_application_path="$1"
	local -i installer_application_type="0"

	is_not_empty "${installer_application_path}" || return 1

	if is_file "${installer_application_path}/Contents/Resources/createinstallmedia"; then
		if is_file "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"; then
			installer_application_type="3"
		else
			installer_application_type="2"
		fi
	else
		installer_application_type="1"
	fi

	echo "${installer_application_type}"
	return 0
}

create_iso_image() {
	local -r source_image="$1"
	local -r destination_image="$2"
	local -r default_volume_name="$3"

	is_not_empty "${source_image}" || return 1
	is_not_empty "${destination_image}" || return 1
	is_not_empty "${default_volume_name}" || return 1

	is_existing "${source_image}" || return 1

	hdiutil makehybrid -o "${destination_image}" "${source_image}" -hfs -udf -default-volume-name "${default_volume_name}" &> /dev/null
}

# ----------------------------------------------------------------------
# Issues an error message about an invalid option and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_invalid_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: unrecognized option \`${option}'"
	else
		echo_error "${const_script_name}: invalid option -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about a missing option parameter for an option
# and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_missing_option_parameter_for_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: option \`${option}' requires an argument"
	else
		echo_error "${const_script_name}: option requires an argument -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about specifying an option parameter for a
# long option where no parameter is allowed and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_no_option_parameter_allowed_for_long_option(){
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' doesn't allow an argument"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about an ambiguous specification for a long
# option and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_ambiguous_long_option() {
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' is ambiguous"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message and exits.
#
# Input:
# $@ - optional error message(s)
# global_exit_with_error_exit_status - if set, used as exit status
# ----------------------------------------------------------------------
exit_with_error() {
	local -r -a error_messages=("$@")

	if (( ${#error_messages[@]} > 0 )); then
		echo_error "${error_messages[@]}"
	fi

	exit "${global_exit_with_error_exit_status:-1}"
}

# ======================================================================
# Main function
# ======================================================================

main () {
	set -o errexit
	set -o errtrace
	set -o nounset
	set -o pipefail

	trap "exit_handler" EXIT
	trap "signal_handler" SIGHUP SIGINT SIGQUIT SIGPIPE SIGTERM

	# ==================================================================
	# Check operating system requirements
	# ==================================================================

	local os_name
	local mac_os_x_major_version

	os_name="$(get_os_name)" || exit_with_error "Couldn't get operating system name."

	if ! is_mac_os_x "${os_name}"; then
		echo_error "This tool must be run on Mac OS X."
		exit 1
	fi

	mac_os_x_major_version="$(get_mac_os_x_major_version)" || exit_with_error "Couldn't get Mac OS X version."

	if is_unsupported_mac_os_x_major_version "${mac_os_x_major_version}"; then
		echo_error "This tool requires Mac OS X ${const_supported_mac_os_x_major_versions[0]} or later."
		exit 1
	fi

	if ! is_supported_mac_os_x_major_version "${mac_os_x_major_version}"; then
		echo_warning "This tool has not been tested on Mac OS X ${mac_os_x_major_version}."
	fi

	# ==================================================================
	# Parse command line arguments
	# ==================================================================

	unset option_applicationpath
	unset option_destinationpath
	local option_genuine="false"
	local option_nointeraction="false"

	local long_option
	local option_parameter

	# This script requires at least four arguments: Two options with one
	# option parameter each. However, this does not take into account
	# that one argument might already consist of an option and its
	# option parameter.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	if (( $# < 4 )); then
		echo_error_usage
		exit 0
	fi

	if ! is_root; then
		echo_error "This tool must be run as root."
		exit 249
	fi

	while [[ "${1+set}" == "set" ]]; do
		case "$1" in

			# Option '--applicationpath'
			-a* | --a* )
				long_option="--applicationpath"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_applicationpath="${option_parameter}"
				;;

			# Option '--destinationpath'
			-d* | --d* )
				long_option="--destinationpath"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_destinationpath="${option_parameter}"
				;;

			# Option '--genuine'
			-g* | --g* )
				long_option="--genuine"

				if is_long_option_including_option_parameter "$1"; then
					is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
					exit_no_option_parameter_allowed_for_long_option "${1%%=*}"
				elif is_long_option "$1"; then
					is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					shift
				elif is_short_options_combination "$1"; then
					set -- "-${1:2}" "${@:2}"
				else
					shift
				fi

				option_genuine="true"
				;;

			# Option '--nointeraction'
			-n* | --n* )
				long_option="--nointeraction"

				if is_long_option_including_option_parameter "$1"; then
					is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
					exit_no_option_parameter_allowed_for_long_option "${1%%=*}"
				elif is_long_option "$1"; then
					is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					shift
				elif is_short_options_combination "$1"; then
					set -- "-${1:2}" "${@:2}"
				else
					shift
				fi

				option_nointeraction="true"
				;;

			# End of options
			-- )
				shift
				break
				;;

			# Ambiguous long option
			--=* )
				exit_ambiguous_long_option "${1%%=*}"
				;;

			# Invalid short or long option
			-[^-]* | --?* )
				exit_invalid_option "$1"
				;;

			# Non-option argument or single '-'
			* )
				shift
				;;

		esac
	done

	# ==================================================================
	# Verify command line options
	# ==================================================================

	if [[ "${option_applicationpath+set}" != "set" || "${option_destinationpath+set}" != "set" ]]; then
		echo_error "You must specify both the destination directory and install application path."
		exit 255
	fi

	if ! is_valid_destination_directory_path "${option_destinationpath}"; then
		echo_error "${option_destinationpath} is not a valid destination directory."
		exit 254
	fi

	if ! is_valid_installer_application_path "${option_applicationpath}"; then
		echo_error "${option_applicationpath} does not appear to be a valid OS installer application."
		exit 253
	fi

	# ==================================================================
	# Check installer application requirements
	# ==================================================================

	local absolute_installer_application_path
	local absolute_destination_directory_path
	local installer_application_display_name

	absolute_installer_application_path="$(get_absolute_logical_path "${option_applicationpath}")" || exit_with_error "Couldn't get absolute path for ${option_applicationpath}."
	absolute_destination_directory_path="$(get_absolute_logical_path "${option_destinationpath}")" || exit_with_error "Couldn't get absolute path for ${option_destinationpath}."

	installer_application_display_name="$(get_installer_application_display_name "${absolute_installer_application_path}")" || exit_with_error "Couldn't get display name of installer application."

	if ! is_supported_installer_application_display_name "${installer_application_display_name}"; then
		echo_warning "${installer_application_display_name} is not a supported installer."
	fi

	# ==================================================================
	# Perform required user interactions
	# ==================================================================

	local iso_destination_file
	local type_of_existing_destination_file

	global_tmp_directory="$(mktemp -d -t "${const_script_name}")" || exit_with_error "Failed to create temporary directory."

	iso_destination_file="${absolute_destination_directory_path}/${installer_application_display_name}.iso"

	if is_existing "${iso_destination_file}"; then
		if is_file "${iso_destination_file}"; then
			type_of_existing_destination_file="file"
		else
			type_of_existing_destination_file="directory"
		fi
		if [[ ! "${option_nointeraction}" == "true" ]]; then
			echo "Ready to start."
			echo "To continue we need to delete the ${type_of_existing_destination_file} ${iso_destination_file}."
			if ! get_user_consent "If you wish to continue type (Y) then press return: "; then
				echo -n "Operation canceled."
				exit 0
			fi
		fi

		rm -rf "${iso_destination_file}" &> /dev/null || exit_with_error "Failed to delete the ${type_of_existing_destination_file} ${iso_destination_file}."
	fi

	# ==================================================================
	# Create writable disk image from BaseSystem.dmg
	# ==================================================================

	local install_esd_dmg_file
	local install_esd_dmg_shadow
	local base_system_dmg_file
	local writable_installer_disk_image_file
	local tmp_installer_disk_image_file

	# Once the script has reached this point of execution, it will
	# return with exit status zero in case of an error and issue an exit
	# message before exiting.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	global_exit_with_error_exit_status="0"
	global_exit_message="Done."

	install_esd_dmg_file="${absolute_installer_application_path}/Contents/SharedSupport/InstallESD.dmg"
	install_esd_dmg_shadow="${global_tmp_directory}/InstallESD.shadow"
	global_install_esd_dmg_mountpoint="${global_tmp_directory}/InstallESD"

	echo -n "Creating Image: 0%..." 1>&2
	hdiutil attach "${install_esd_dmg_file}" -shadow "${install_esd_dmg_shadow}" -readonly -kernel -mountpoint "${global_install_esd_dmg_mountpoint}" -nobrowse &> /dev/null || { echo 1>&2; exit_with_error "Couldn't mount dmg ${install_esd_dmg_file}."; }

	base_system_dmg_file="${global_install_esd_dmg_mountpoint}/BaseSystem.dmg"

	is_file "${base_system_dmg_file}" || { echo 1>&2; exit_with_error "BaseSystem missing from the outer dmg, damaged installer image?"; }

	writable_installer_disk_image_file="${global_tmp_directory}/WritableInstallerDiskImage.sparsebundle"
	global_writable_installer_disk_image_mountpoint="${global_tmp_directory}/WritableInstallerDiskImage"

	# Decide based on the option '--genuine' which method should be used
	# to create the writable installer disk image.
	#
	# If the option '--genuine' is used, the image will be created by
	# converting the BaseSystem.dmg to a writable disk image. This
	# method creates an ISO image that is most close to Apple's Install
	# DVD, but potentially less compatible with some BIOS/UEFI.
	#
	# The default method is to first create an ISO image from the
	# BaseSystem.dmg and then convert the ISO image to a writable disk
	# image. This method is most compatible with non-Apple BIOS/UEFIs.
	if [[ "${option_genuine}" == "true" ]]; then
		echo -n " 50%..." 1>&2
		hdiutil convert "${base_system_dmg_file}" -format UDSB -o "${writable_installer_disk_image_file}" -pmap &> /dev/null || { echo 1>&2; exit_with_error "Couldn't convert BaseSystem to writable disk image."; }
	else
		echo -n " 30%..." 1>&2
		tmp_installer_disk_image_file="${global_tmp_directory}/TemporaryInstallerDiskImage.dmg"
		hdiutil create -srcdevice "${base_system_dmg_file}" "${tmp_installer_disk_image_file}" -layout ISOCD &> /dev/null || { echo 1>&2; exit_with_error "Couldn't create temporary disk image from BaseSystem."; }

		echo -n " 60%..." 1>&2
		hdiutil convert "${tmp_installer_disk_image_file}" -format UDSB -o "${writable_installer_disk_image_file}" -pmap &> /dev/null || { echo 1>&2; exit_with_error "Couldn't convert temporary disk image to writable disk image."; }
		rm -f "${tmp_installer_disk_image_file}" &> /dev/null
	fi

	# ==================================================================
	# Resize writable disk image
	# ==================================================================

	local -i base_system_dmg_total_bytes
	local -i install_esd_dmg_total_non_empty_bytes
	local -i writable_installer_disk_image_size

	base_system_dmg_total_bytes="$(get_disk_image_total_bytes "${base_system_dmg_file}")" || { echo 1>&2; exit_with_error "Couldn't get total bytes of disk image ${base_system_dmg_file}."; }
	install_esd_dmg_total_non_empty_bytes="$(get_disk_image_total_non_empty_bytes "${install_esd_dmg_file}")" || { echo 1>&2; exit_with_error "Couldn't get total non-empty bytes of disk image ${install_esd_dmg_file}."; }

	# Calculate the required size of the writable installer disk image.
	#
	# The size of the writable installer disk image must be increased
	# beyond its current size to store the Packages directory contained
	# in the InstallESD.dmg disk image, and the BaseSystem.dmg file
	# which both will be copied to the writable disk image.
	#
	# The Packages directory and the file BaseSystem.dmg are both
	# contained in the InstallESD.dmg disk image and typically account
	# for more than 98% of the content of the InstallESD.dmg disk image.
	#
	# Therefore, the total number of non empty bytes in the
	# InstallESD.dmg disk image can be used as a good guess for the
	# required size increase of the writable installer disk image.
	#
	# NOTE: The size of the writable installer disk image does not
	# affect the size of the final ISO image.
	(( writable_installer_disk_image_size = base_system_dmg_total_bytes + install_esd_dmg_total_non_empty_bytes ))

	# Add 10% for potential overhead
	(( writable_installer_disk_image_size = writable_installer_disk_image_size + (writable_installer_disk_image_size / 10) ))

	# Round up to the next sector boundary
	(( writable_installer_disk_image_size = ((writable_installer_disk_image_size / 512) + 1) * 512 ))

	hdiutil resize -size "${writable_installer_disk_image_size}" "${writable_installer_disk_image_file}" -nofinalgap &> /dev/null || { echo 1>&2; exit_with_error "Couldn't resize writable disk image."; }

	hdiutil attach "${writable_installer_disk_image_file}" -readwrite -mountpoint "${global_writable_installer_disk_image_mountpoint}" -nobrowse &> /dev/null || { echo 1>&2; exit_with_error "Couldn't mount writable disk image."; }
	echo "100%..." 1>&2

	# ==================================================================
	# Copy installer files to disk image
	# ==================================================================

	echo "Copying installer files to disk image..."
	rm -f "${global_writable_installer_disk_image_mountpoint}/System/Installation/Packages" &> /dev/null || exit_with_error "Failed to delete Packages symlink."
	cp -pPR "${global_install_esd_dmg_mountpoint}/Packages" "${global_writable_installer_disk_image_mountpoint}/System/Installation/" &> /dev/null || exit_with_error "Failed to copy Packages directory."

	cp -p "${base_system_dmg_file}" "${global_writable_installer_disk_image_mountpoint}/" &> /dev/null || exit_with_error "Failed to copy BaseSystem.dmg."
	cp -p "${base_system_dmg_file%.dmg}.chunklist" "${global_writable_installer_disk_image_mountpoint}/" &> /dev/null || exit_with_error "Failed to copy BaseSystem.chunklist."
	echo "Copy complete."

	# ==================================================================
	# Make disk image bootable
	# ==================================================================

	local core_services_directory

	echo "Making disk image bootable..."
	core_services_directory="${global_writable_installer_disk_image_mountpoint}/System/Library/CoreServices"
	bless --folder "${core_services_directory}" --file "${core_services_directory}/boot.efi" --openfolder "${global_writable_installer_disk_image_mountpoint}" --label "${installer_application_display_name}" &> /dev/null || exit_with_error "The bless of the installer disk image failed."

	hdiutil detach "${global_writable_installer_disk_image_mountpoint}" -force &> /dev/null || exit_with_error "Couldn't unmount writable disk image."
	unset global_writable_installer_disk_image_mountpoint

	# ==================================================================
	# Create ISO image
	# ==================================================================

	local source_device_id
	local destination_device_id

	echo "Creating ISO image..."
	source_device_id="$(stat -f '%d' "${global_tmp_directory}")" || exit_with_error "Couldn't get device ID for temporary directory."
	destination_device_id="$(stat -f '%d' "${absolute_destination_directory_path}")" || exit_with_error "Couldn't get device ID for destination directory."

	# If the ISO destination file is located on the same device as the
	# temporary directory, the ISO image will be created in the
	# temporary directory and then moved to the destination.
	if [[ "${destination_device_id}" == "${source_device_id}" ]]; then
		create_iso_image "${writable_installer_disk_image_file}" "${global_tmp_directory}/InstallerDiskImage.iso" "${installer_application_display_name}" || exit_with_error "Failed to create ISO image."
		mv -f "${global_tmp_directory}/InstallerDiskImage.iso" "${iso_destination_file}" &> /dev/null || exit_with_error "Couldn't move ISO image to destination directory."
	else
		global_incomplete_iso_destination_file="${iso_destination_file}"
		create_iso_image "${writable_installer_disk_image_file}" "${iso_destination_file}" "${installer_application_display_name}" || exit_with_error "Failed to create ISO image."
		unset global_incomplete_iso_destination_file
	fi

	exit 0
}

main "$@"