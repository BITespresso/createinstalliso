#!/bin/bash

# createinstalliso - Creates a bootable ISO image from a Mac OS X
# installer application.
# Copyright (C) 2017 Michael Berger <michael.berger@gmx.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

if ! [ -n "${BASH}" ]; then
	echo "This tool must be run in Bash shell." 1>&2
	exit 1
fi

declare -r const_script_name="createinstalliso"
declare -r -i const_root_uid="0"

# This script requires /usr/libexec/PlistBuddy to read values from
# property list files. PlistBuddy is available on Mac OS X 10.5 Leopard
# or later. However on Mac OS X 10.5 Leopard PlistBuddy does not handle
# large integer values correctly. Therefore, this script requires
# Mac OS X 10.6 Snow Leopard or later.
declare -r -a const_unsupported_mac_os_x_major_versions=(
	"10.0"  # Mac OS X Cheetah
	"10.1"  # Mac OS X Puma
	"10.2"  # Mac OS X Jaguar
	"10.3"  # Mac OS X Panther
	"10.4"  # Mac OS X Tiger
	"10.5"  # Mac OS X Leopard
)

# This script has been tested on the following Mac OS X major versions.
declare -r -a const_supported_mac_os_x_major_versions=(
	"10.6"  # Mac OS X Snow Leopard
	"10.7"  # Mac OS X Lion
	"10.8"  # OS X Mountain Lion
	"10.9"  # OS X Mavericks
	"10.10" # OS X Yosemite
	"10.11" # OS X El Capitan
	"10.12" # macOS Sierra
)

# This script has been tested with the following installer applications.
declare -r -a const_supported_installer_application_display_names=(
	"Install Mac OS X Lion"      # 10.7
	"Install OS X Mountain Lion" # 10.8
	"Install OS X Mavericks"     # 10.9
	"Install OS X Yosemite"      # 10.10
	"Install OS X El Capitan"    # 10.11
	"Install macOS Sierra"       # 10.12
)

unset global_exit_message
unset global_tmp_directory
unset global_incomplete_iso_destination_image
declare -i global_exit_with_error_exit_status="1"

# ======================================================================
# Helper functions
# ======================================================================

exit_handler() {
	trap - EXIT
	cleanup

	if is_not_empty "${global_exit_message-}"; then
		echo "${global_exit_message}"
		unset global_exit_message
	fi
}

signal_handler() {
	local -r -i exit_status="$?"

	trap - EXIT
	cleanup

	unset global_exit_message
	exit "${exit_status}"
}

cleanup() {
	if is_not_empty "${global_tmp_directory-}" && is_existing "${global_tmp_directory}"; then
		rm -rf "${global_tmp_directory}" &> /dev/null && unset global_tmp_directory
	fi

	# Remove the incomplete destination image if the user interrupts the
	# script while creating the final ISO image.
	if is_not_empty "${global_incomplete_iso_destination_image-}" && is_existing "${global_incomplete_iso_destination_image}"; then
		rm -rf "${global_incomplete_iso_destination_image}" &> /dev/null && unset global_incomplete_iso_destination_image
	fi
	return 0
}

echo_warning() {
	echo -n "+++ WARNING: " 1>&2
	echo "$@" 1>&2
	return 0
}

echo_error() {
	echo "$@" 1>&2
	return 0
}

echo_error_usage() {
	cat <<-EOF 1>&2
	Usage: ${const_script_name} --destinationpath <path to destination directory> --applicationpath <path to OS installer application> [--nointeraction]

	Arguments--destinationpath, A path to a directory where the installer ISO image will be created.
	--applicationpath, A path to copy of the OS installer application to create the bootable ISO image from.
	--nointeraction, Delete an existing file (or directory) in the destination directory when it has the same name as the target ISO image without prompting for confirmation.

	Example: ${const_script_name} --destinationpath ~/Desktop --applicationpath "/Applications/$(get_example_installer_application_name)"
EOF
	if ! is_root; then
		echo_error
		echo_error "This tool must be run as root."
	fi
	return 0
}

is_not_empty() {
	local -r string="$1"

	[[ -n "${string}" ]]
}

is_existing() {
	local -r file_or_directory="$1"

	[[ -e "${file_or_directory}" ]]
}

is_file() {
	local -r file_or_directory="$1"

	[[ -f "${file_or_directory}" ]]
}

is_directory() {
	local -r file_or_directory="$1"

	[[ -d "${file_or_directory}" ]]
}

is_root() {
	[[ "$(id -u)" -eq "${const_root_uid}" ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is an option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_option_including_option_parameter() {
	local -r argument="$1"

	is_long_option_including_option_parameter "${argument}" || is_short_option_including_option_parameter "${argument}"
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == --*=* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a short option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option() {
	local -r argument="$1"

	[[ "${argument}" == --?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a valid abbreviation for a given long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
# $2 - long option (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_valid_long_option() {
	local -r argument="$1"
	local -r long_option="$2"

	is_long_option "${argument}" || return 1

	[[ "${long_option}" == "${argument}"* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a combination of multiple short options.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_options_combination() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

is_valid_destination_directory_path() {
	local -r destination_directory_path="$1"

	is_not_empty "${destination_directory_path}" || return 1

	is_directory "${destination_directory_path}"
}

is_valid_installer_application_path() {
	local -r installer_application_path="$1"
	local installer_application_display_name=""
	local -i installer_application_type="0"

	local installer_application_short_version_string
	local valid_installer_application_short_version_string_regex='^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+$'

	local installer_application_identifier
	local valid_installer_application_identifier_regex='^com\.apple\.InstallAssistant\.[a-zA-Z0-9.-]+$'

	local system_image_url

	is_not_empty "${installer_application_path}" || return 1
	is_directory "${installer_application_path}" || return 1

	# Check if the installer application display name can be retrieved.
	# The installer application display name is required to verify the
	# compatibility of the script.
	installer_application_display_name="$(get_installer_application_display_name "${installer_application_path}")" || return 1
	is_not_empty "${installer_application_display_name}" || return 1

	installer_application_type="$(get_installer_application_type "${installer_application_path}")" || return 1

	case "${installer_application_type}" in

		# '1' - Installer application type for Mac OS X 10.7 to 10.8
		1 )
			# This file is required because it will be used as source
			# to create the installer disk image.
			is_file "${installer_application_path}/Contents/SharedSupport/InstallESD.dmg" || return 1

			return 0
			;;

		# '2' - Installer application type for Mac OS X 10.9 to 10.11
		2 )
			# Apple's command 'createinstallmedia' is required because
			# it will be used to create the installer disk image.
			is_file "${installer_application_path}/Contents/Resources/createinstallmedia" || return 1

			# All subsequent checks are the same as those performed by
			# Apple's command 'createinstallmedia' to determine if the
			# OS installer application is valid.
			is_file "${installer_application_path}/Contents/SharedSupport/InstallESD.dmg" || return 1
			is_file "${installer_application_path}/Contents/SharedSupport/OSInstall.mpkg" || return 1

			if is_file "${installer_application_path}/Contents/Info.plist"; then
				installer_application_short_version_string="$(get_installer_application_short_version_string "${installer_application_path}")" || return 1
				[[ "${installer_application_short_version_string}" =~ ${valid_installer_application_short_version_string_regex} ]] || return 1

				installer_application_identifier="$(get_installer_application_identifier "${installer_application_path}")" || return 1
				[[ "${installer_application_identifier}" =~ ${valid_installer_application_identifier_regex} ]] || return 1
			else
				return 1
			fi

			return 0
			;;

		# '3' - Installer application type for Mac OS X 10.12 to 10.13
		3 )
			# Apple's command 'createinstallmedia' is required because
			# it will be used to create the installer disk image.
			is_file "${installer_application_path}/Contents/Resources/createinstallmedia" || return 1

			# All subsequent checks are the same as those performed by
			# Apple's command 'createinstallmedia' to determine if the
			# OS installer application is valid.
			if is_file "${installer_application_path}/Contents/Info.plist"; then
				installer_application_short_version_string="$(get_installer_application_short_version_string "${installer_application_path}")" || return 1
				[[ "${installer_application_short_version_string}" =~ ${valid_installer_application_short_version_string_regex} ]] || return 1

				installer_application_identifier="$(get_installer_application_identifier "${installer_application_path}")" || return 1
				[[ "${installer_application_identifier}" =~ ${valid_installer_application_identifier_regex} ]] || return 1
			else
				return 1
			fi

			if is_file "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"; then
				system_image_url="$(get_system_image_url "${installer_application_path}")" || return 1
				is_file "${installer_application_path}/Contents/SharedSupport/${system_image_url}" || return 1
			else
				return 1
			fi

			return 0
			;;

	esac
	return 1
}

# ----------------------------------------------------------------------
# Checks if an operating system is Mac OS X.
#
# Input:
# $1 - operating system name
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_mac_os_x() {
	local -r os_name="$1"

	is_not_empty "${os_name}" || return 1

	[[ "${os_name}" == "Darwin" ]]
}

is_valid_mac_os_x_version() {
	local -r mac_os_x_version="$1"
	local -r valid_mac_os_x_version_regex='^10\.[[:digit:]]+(\.[[:digit:]]+)?$'

	[[ "${mac_os_x_version}" =~ ${valid_mac_os_x_version_regex} ]]
}

is_unsupported_mac_os_x_major_version() {
	local -r mac_os_x_major_version="$1"

	is_array_item "${mac_os_x_major_version}" "const_unsupported_mac_os_x_major_versions"
}

is_supported_mac_os_x_major_version() {
	local -r mac_os_x_major_version="$1"

	is_array_item "${mac_os_x_major_version}" "const_supported_mac_os_x_major_versions"
}

is_supported_installer_application_display_name() {
	local -r installer_application_display_name="$1"

	is_array_item "${installer_application_display_name}" "const_supported_installer_application_display_names"
}

# ----------------------------------------------------------------------
# Checks if an item is contained in an array. The array is passed to the
# function by reference via its name.
#
# Input:
# $1 - item
# $2 - name of the array as string
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_array_item() {
	local -r item="$1"
	local -r array_name="$2[@]"
	local current_item

	for current_item in "${!array_name}"; do
		if [[ "${current_item}" == "${item}" ]]; then
			return 0
		fi
	done
	return 1
}

# ----------------------------------------------------------------------
# Executes a PlistBuddy command on a property list file.
#
# Input:
# $1 - command to be executed by PlistBuddy
# $2 - property list file
#
# Output:
# output of PlistBuddy
# ----------------------------------------------------------------------
execute_plist_buddy_command() {
	local -r plist_command="$1"
	local -r plist_file="$2"

	is_not_empty "${plist_command}" || return 1
	is_not_empty "${plist_file}" || return 1

	/usr/libexec/PlistBuddy -c "${plist_command}" "${plist_file}" 2> /dev/null
}

# ----------------------------------------------------------------------
# Returns the name of the running operating system.
#
# Output:
# operating system name
# ----------------------------------------------------------------------
get_os_name() {
	local os_name

	os_name="$(uname -s 2> /dev/null)" || return 1

	echo "${os_name}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the major version of the running Mac OS X operating system.
#
# Output:
# Mac OS X major version
# ----------------------------------------------------------------------
get_mac_os_x_major_version() {
	local mac_os_x_version
	local mac_os_x_major_version

	mac_os_x_version="$(sw_vers -productVersion 2> /dev/null)" || return 1
	is_valid_mac_os_x_version "${mac_os_x_version}" || return 1

	mac_os_x_major_version="$(get_mac_os_x_major_version_from_mac_os_x_version "${mac_os_x_version}")" || return 1

	echo "${mac_os_x_major_version}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the major version part of a Mac OS X version number. Example:
# The major version part of the version number '10.12.6' is '10.12'.
#
# Input:
# $1 - Mac OS X version number
#
# Output:
# major version part of the Mac OS X version number
# ----------------------------------------------------------------------
get_mac_os_x_major_version_from_mac_os_x_version() {
	local -r mac_os_x_version="$1"
	local mac_os_x_major_version
	local -r valid_mac_os_x_major_version_regex='^10\.[[:digit:]]+$'

	is_valid_mac_os_x_version "${mac_os_x_version}" || return 1

	if [[ "${mac_os_x_version}" =~ ${valid_mac_os_x_major_version_regex} ]]; then
		mac_os_x_major_version="${mac_os_x_version}"
	else
		mac_os_x_major_version="${mac_os_x_version%.*}"
	fi

	echo "${mac_os_x_major_version}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the value of an entry in a property list file.
#
# Input:
# $1 - entry
# $2 - property list file
#
# Output:
# value of the specified entry
# ----------------------------------------------------------------------
get_plist_value() {
	local -r entry="$1"
	local -r plist_file="$2"

	is_not_empty "${entry}" || return 1
	is_not_empty "${plist_file}" || return 1

	execute_plist_buddy_command "Print '${entry}'" "${plist_file}"
}

# ----------------------------------------------------------------------
# Returns the display name of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# display name of the installer application
# ----------------------------------------------------------------------
get_installer_application_display_name() {
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleDisplayName" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the short version string of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# short version string
# ----------------------------------------------------------------------
get_installer_application_short_version_string()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleShortVersionString" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the identifier of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# identifier
# ----------------------------------------------------------------------
get_installer_application_identifier()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleIdentifier" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the URL of the system image within an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# URL of the system image
# ----------------------------------------------------------------------
get_system_image_url()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":System Image Info:URL" "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"
}

# ----------------------------------------------------------------------
# Returns the absolute logical path to a file or directory.
#
# Input:
# $1 - absolute or relative path to a file or directory
#
# Output:
# absolute logical (i.e. not the physical) path to the file or directory
# ----------------------------------------------------------------------
get_absolute_logical_path() {
	local -r file_or_directory="$1"

	is_not_empty "${file_or_directory}" || return 1
	is_existing "${file_or_directory}" || return 1

	if is_directory "${file_or_directory}"; then
		echo "$(cd "${file_or_directory}"; pwd -L)"
	else
		if [[ "${file_or_directory}" == */* ]]; then
			echo "$(cd "${file_or_directory%/*}"; pwd -L)/${file_or_directory##*/}"
		else
			echo "$(pwd -L)/${file_or_directory}"
		fi
	fi
	return 0
}

# ----------------------------------------------------------------------
# Asks the user for consent on the command line. Any user input starting
# with 'y' or 'Y' will be treated as consent.
#
# Input:
# $1 - prompt to be displayed on the command line
#
# Output:
# none - returns with exit status zero if user gave his consent
# ----------------------------------------------------------------------
get_user_consent() {
	local -r prompt="$1"
	local input
	local -r yes_regex='^[yY].*$'

	echo -n "${prompt}"
	input="$(IFS=""; read -r input; echo "${input}")"

	[[ "${input}" =~ ${yes_regex} ]]
}

get_example_installer_application_name() {
	local -r -i number_of_elements="${#const_supported_installer_application_display_names[@]}"
	local example_installer_application_name="${const_supported_installer_application_display_names[${number_of_elements}-1]}.app"
	local -i i

	for (( i = number_of_elements - 1; i >= 0; i-- )); do
		if is_valid_installer_application_path "/Applications/${const_supported_installer_application_display_names[${i}]}.app"; then
			example_installer_application_name="${const_supported_installer_application_display_names[${i}]}.app"
			break
		fi
	done

	echo "${example_installer_application_name}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the type of an installer application. The type is determined
# by checking the presence of some files that are specific to the
# different installer types.
#
# The returned types are:
#
# '0' - Installer application type unknown
# '1' - Installer application type for Mac OS X 10.7 to 10.8
# '2' - Installer application type for Mac OS X 10.9 to 10.11
# '3' - Installer application type for Mac OS X 10.12 to 10.13
#
# Input:
# $1 - path to the installer application
#
# Output:
# type of the installer application
# ----------------------------------------------------------------------
get_installer_application_type()
{
	local -r installer_application_path="$1"
	local -i installer_application_type="0"

	is_not_empty "${installer_application_path}" || return 1

	if is_file "${installer_application_path}/Contents/Resources/createinstallmedia"; then
		if is_file "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"; then
			installer_application_type="3"
		else
			installer_application_type="2"
		fi
	else
		installer_application_type="1"
	fi

	echo "${installer_application_type}"
	return 0
}

create_iso_image() {
	local -r source_image="$1"
	local -r destination_image="$2"
	local -r default_volume_name="$3"

	is_not_empty "${source_image}" || return 1
	is_not_empty "${destination_image}" || return 1
	is_not_empty "${default_volume_name}" || return 1

	is_existing "${source_image}" || return 1

	hdiutil makehybrid -o "${destination_image}" "${source_image}" -hfs -udf -default-volume-name "${default_volume_name}" &> /dev/null
}

# ----------------------------------------------------------------------
# Issues an error message about an invalid option and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_invalid_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: unrecognized option \`${option}'"
	else
		echo_error "${const_script_name}: invalid option -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about a missing option parameter for an option
# and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_missing_option_parameter_for_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: option \`${option}' requires an argument"
	else
		echo_error "${const_script_name}: option requires an argument -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about specifying an option parameter for a
# long option where no parameter is allowed and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_no_option_parameter_allowed_for_long_option(){
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' doesn't allow an argument"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about an ambiguous specification for a long
# option and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_ambiguous_long_option() {
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' is ambiguous"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message and exits.
#
# Input:
# $@ - optional error message(s)
# global_exit_with_error_exit_status - if set, used as exit status
# ----------------------------------------------------------------------
exit_with_error() {
	local -r -a error_messages=("$@")

	if (( ${#error_messages[@]} > 0 )); then
		echo_error "${error_messages[@]}"
	fi

	exit "${global_exit_with_error_exit_status:-1}"
}

# ======================================================================
# Main function
# ======================================================================

main() {
	set -o errexit
	set -o errtrace
	set -o nounset
	set -o pipefail

	trap "exit_handler" EXIT
	trap "signal_handler" SIGHUP SIGINT SIGQUIT SIGPIPE SIGTERM

	# ==================================================================
	# Check operating system requirements
	# ==================================================================

	local os_name
	local mac_os_x_major_version

	os_name="$(get_os_name)" || exit_with_error "Couldn't get operating system name."

	if ! is_mac_os_x "${os_name}"; then
		echo_error "This tool must be run on Mac OS X."
		exit 1
	fi

	mac_os_x_major_version="$(get_mac_os_x_major_version)" || exit_with_error "Couldn't get Mac OS X version."

	if is_unsupported_mac_os_x_major_version "${mac_os_x_major_version}"; then
		echo_error "This tool requires Mac OS X ${const_supported_mac_os_x_major_versions[0]} or later."
		exit 1
	fi

	if ! is_supported_mac_os_x_major_version "${mac_os_x_major_version}"; then
		echo_warning "This tool has not been tested on Mac OS X ${mac_os_x_major_version}."
	fi

	# ==================================================================
	# Parse command line arguments
	# ==================================================================

	unset option_applicationpath
	unset option_destinationpath
	local option_nointeraction="false"

	local long_option
	local option_parameter

	# This script requires at least four arguments: Two options with one
	# option parameter each. However, this does not take into account
	# that one argument might already consist of an option and its
	# option parameter.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	if (( $# < 4 )); then
		echo_error_usage
		exit 0
	fi

	if ! is_root; then
		echo_error "This tool must be run as root."
		exit 249
	fi

	while [[ "${1+set}" == "set" ]]; do
		case "$1" in

			# Option '--applicationpath'
			-a* | --a* )
				long_option="--applicationpath"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_applicationpath="${option_parameter}"
				;;

			# Option '--destinationpath'
			-d* | --d* )
				long_option="--destinationpath"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_destinationpath="${option_parameter}"
				;;

			# Option '--nointeraction'
			-n* | --n* )
				long_option="--nointeraction"

				if is_long_option_including_option_parameter "$1"; then
					is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
					exit_no_option_parameter_allowed_for_long_option "${1%%=*}"
				elif is_long_option "$1"; then
					is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					shift
				elif is_short_options_combination "$1"; then
					set -- "-${1:2}" "${@:2}"
				else
					shift
				fi

				option_nointeraction="true"
				;;

			# End of options
			-- )
				shift
				break
				;;

			# Ambiguous long option
			--=* )
				exit_ambiguous_long_option "${1%%=*}"
				;;

			# Invalid short or long option
			-[^-]* | --?* )
				exit_invalid_option "$1"
				;;

			# Non-option argument or single '-'
			* )
				shift
				;;

		esac
	done

	# ==================================================================
	# Verify command line options
	# ==================================================================

	if [[ "${option_applicationpath+set}" != "set" || "${option_destinationpath+set}" != "set" ]]; then
		echo_error "You must specify both the destination directory and install application path."
		exit 255
	fi

	if ! is_valid_destination_directory_path "${option_destinationpath}"; then
		echo_error "${option_destinationpath} is not a valid destination directory."
		exit 254
	fi

	if ! is_valid_installer_application_path "${option_applicationpath}"; then
		echo_error "${option_applicationpath} does not appear to be a valid OS installer application."
		exit 253
	fi

	# ==================================================================
	# Initialization
	# ==================================================================

	local installer_application_path
	local destination_directory_path
	local installer_application_display_name
	local -i installer_application_type
	local iso_destination_image

	installer_application_path="$(get_absolute_logical_path "${option_applicationpath}")" || exit_with_error "Couldn't get absolute path for ${option_applicationpath}."
	destination_directory_path="$(get_absolute_logical_path "${option_destinationpath}")" || exit_with_error "Couldn't get absolute path for ${option_destinationpath}."

	installer_application_display_name="$(get_installer_application_display_name "${installer_application_path}")" || exit_with_error "Couldn't get installer application display name."
	installer_application_type="$(get_installer_application_type "${installer_application_path}")" || exit_with_error "Couldn't get installer application type."
	iso_destination_image="${destination_directory_path}/${installer_application_display_name}.iso"

	global_tmp_directory="$(mktemp -d -t "${const_script_name}")" || exit_with_error "Failed to create temporary directory."

	# ==================================================================
	# Check installer application requirements
	# ==================================================================

	if ! is_supported_installer_application_display_name "${installer_application_display_name}"; then
		echo_warning "${installer_application_display_name} is not a supported installer."
	fi

	# ==================================================================
	# Perform required user interactions
	# ==================================================================

	local type_of_existing_destination

	if is_existing "${iso_destination_image}"; then
		if is_file "${iso_destination_image}"; then
			type_of_existing_destination="file"
		else
			type_of_existing_destination="directory"
		fi
		if [[ ! "${option_nointeraction}" == "true" ]]; then
			echo "Ready to start."
			echo "To continue we need to delete the ${type_of_existing_destination} ${iso_destination_image}."
			if ! get_user_consent "If you wish to continue type (Y) then press return: "; then
				echo -n "Operation canceled."
				exit 0
			fi
		fi

		rm -rf "${iso_destination_image}" &> /dev/null || exit_with_error "Failed to delete the ${type_of_existing_destination} ${iso_destination_image}."
	fi

	# Once the script has reached this point of execution, it will
	# return with exit status zero in case of an error and issue an exit
	# message before exiting.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	global_exit_with_error_exit_status="0"
	global_exit_message="Done."

	exit 0
}

main "$@"
