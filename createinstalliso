#!/bin/bash

# createinstalliso - Creates a bootable ISO image from a macOS
# installer application.
# Copyright (C) 2017 Michael Berger <michael.berger@gmx.de>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

if ! [ -n "${BASH}" ]; then
	echo "This tool must be run in Bash shell." 1>&2
	exit 1
fi

declare -r const_script_name="createinstalliso"
declare -r -i const_root_uid="0"

# This script requires /usr/libexec/PlistBuddy to read values from
# property list files. PlistBuddy is available on Mac OS X 10.5 Leopard
# or later. However on Mac OS X 10.5 Leopard PlistBuddy does not handle
# large integer values correctly. Therefore, this script requires
# Mac OS X 10.6 Snow Leopard or later.
declare -r -a const_unsupported_macos_minor_versions=(
	"0"  # Mac OS X Cheetah      10.0
	"1"  # Mac OS X Puma         10.1
	"2"  # Mac OS X Jaguar       10.2
	"3"  # Mac OS X Panther      10.3
	"4"  # Mac OS X Tiger        10.4
	"5"  # Mac OS X Leopard      10.5
)

# This script has been tested on the following macOS versions.
declare -r -a const_supported_macos_minor_versions=(
	"6"  # Mac OS X Snow Leopard 10.6
	"7"  # Mac OS X Lion         10.7
	"8"  # OS X Mountain Lion    10.8
	"9"  # OS X Mavericks        10.9
	"10" # OS X Yosemite         10.10
	"11" # OS X El Capitan       10.11
	"12" # macOS Sierra          10.12
)

# This script has been tested with the following installer applications.
declare -r -a const_supported_installer_application_display_names=(
	"Install Mac OS X Lion"      # 10.7
	"Install OS X Mountain Lion" # 10.8
	"Install OS X Mavericks"     # 10.9
	"Install OS X Yosemite"      # 10.10
	"Install OS X El Capitan"    # 10.11
	"Install macOS Sierra"       # 10.12
)

declare -r -a const_macos_names=(
	"Mac OS X Cheetah"      # 10.0 "Cheetah"
	"Mac OS X Puma"         # 10.1 "Puma"
	"Mac OS X Jaguar"       # 10.2 "Jaguar"
	"Mac OS X Panther"      # 10.3 "Panther"
	"Mac OS X Tiger"        # 10.4 "Tiger"
	"Mac OS X Leopard"      # 10.5 "Leopard"
	"Mac OS X Snow Leopard" # 10.6 "Snow Leopard"
	"Mac OS X Lion"         # 10.7 "Lion"
	"OS X Mountain Lion"    # 10.8 "Mountain Lion"
	"OS X Mavericks"        # 10.9 "Mavericks"
	"OS X Yosemite"         # 10.10 "Yosemite"
	"OS X El Capitan"       # 10.11 "El Capitan"
	"macOS Sierra"          # 10.12 "Sierra"
	"macOS High Sierra"     # 10.13 "High Sierra"
	"macOS Mojave"          # 10.14 "Mojave"
	"macOS Catalina"        # 10.15 "Catalina"
)

unset global_exit_message
unset global_tmp_directory
unset global_install_media_device_node
unset global_incomplete_iso_target_image
declare -i global_exit_with_error_exit_status="1"

# ======================================================================
# Helper functions
# ======================================================================

exit_handler() {
	trap - EXIT
	cleanup

	if is_not_empty "${global_exit_message-}"; then
		echo "${global_exit_message}"
		unset global_exit_message
	fi
}

signal_handler() {
	local -r -i exit_status="$?"

	trap - EXIT
	cleanup

	unset global_exit_message
	exit "${exit_status}"
}

cleanup() {
	if is_not_empty "${global_tmp_directory-}" && is_existing "${global_tmp_directory}"; then
		if is_not_empty "${global_install_media_device_node-}" && is_existing "${global_install_media_device_node}"; then
			hdiutil detach "${global_install_media_device_node}" -force &> /dev/null && unset global_install_media_device_node
		fi

		rm -rf "${global_tmp_directory}" &> /dev/null && unset global_tmp_directory
	fi

	if is_not_empty "${global_incomplete_iso_target_image-}" && is_existing "${global_incomplete_iso_target_image}"; then
		rm -rf "${global_incomplete_iso_target_image}" &> /dev/null && unset global_incomplete_iso_target_image
	fi

	return 0
}

echo_warning() {
	echo -n "WARNING: " 1>&2
	echo "$@" 1>&2
	return 0
}

echo_error() {
	echo "$@" 1>&2
	return 0
}

echo_error_usage() {
	cat <<-EOF 1>&2
	Usage: ${const_script_name} --targetdirectory <path to target directory> --applicationpath <path to OS installer application> [--nointeraction]

	Arguments
	--targetdirectory, A path to a directory where the installer ISO image will be created.
	--applicationpath, A path to copy of the OS installer application to create the bootable ISO image from.
	--nointeraction, Delete an existing ISO image without prompting for confirmation.

	Example: ${const_script_name} --targetdirectory ~/Desktop --applicationpath "/Applications/$(get_example_installer_application_name)"
EOF
	if ! is_root; then
		echo_error
		echo_error "This tool must be run as root."
	fi
	return 0
}

is_not_empty() {
	local -r string="$1"

	[[ -n "${string}" ]]
}

is_existing() {
	local -r file_or_directory="$1"

	[[ -e "${file_or_directory}" ]]
}

is_file() {
	local -r file_or_directory="$1"

	[[ -f "${file_or_directory}" ]]
}

is_directory() {
	local -r file_or_directory="$1"

	[[ -d "${file_or_directory}" ]]
}

is_root() {
	[[ "$(id -u)" -eq "${const_root_uid}" ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is an option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_option_including_option_parameter() {
	local -r argument="$1"

	is_long_option_including_option_parameter "${argument}" || is_short_option_including_option_parameter "${argument}"
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == --*=* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a short option including an option parameter.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_option_including_option_parameter() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_long_option() {
	local -r argument="$1"

	[[ "${argument}" == --?* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a valid abbreviation for a given long option.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
# $2 - long option (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_valid_long_option() {
	local -r argument="$1"
	local -r long_option="$2"

	is_long_option "${argument}" || return 1

	[[ "${long_option}" == "${argument}"* ]]
}

# ----------------------------------------------------------------------
# Checks if an argument is a combination of multiple short options.
#
# Input:
# $1 - argument as provided on the command line (including leading '-')
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_short_options_combination() {
	local -r argument="$1"

	[[ "${argument}" == -[^-]?* ]]
}

is_valid_target_directory_path() {
	local -r target_directory_path="$1"

	is_not_empty "${target_directory_path}" || return 1

	is_directory "${target_directory_path}"
}

is_valid_installer_application_path() {
	local -r installer_application_path="$1"
	local installer_application_display_name=""
	local -i installer_application_type="0"

	local installer_application_short_version_string
	local valid_installer_application_short_version_string_regex='^[[:digit:]]+\.[[:digit:]]+\.[[:digit:]]+$'

	local installer_application_identifier
	local valid_installer_application_identifier_regex='^com\.apple\.InstallAssistant\.[a-zA-Z0-9.-]+$'

	local installer_minimum_macos_version_string
	local valid_installer_minimum_macos_version_string_regex='^[[:digit:]]+\.[[:digit:]]+\.?[[:digit:]]*$'

	local system_image_url

	is_not_empty "${installer_application_path}" || return 1
	is_directory "${installer_application_path}" || return 1

	# Check if the installer application display name can be retrieved.
	# The installer application display name is required to verify the
	# compatibility of the script.
	installer_application_display_name="$(get_installer_application_display_name "${installer_application_path}")" || return 1
	is_not_empty "${installer_application_display_name}" || return 1

	installer_application_type="$(get_installer_application_type "${installer_application_path}")" || return 1

	case "${installer_application_type}" in

		# '1' - Installer application type for:
		# - Mac OS X Lion 10.7
		# - OS X Mountain Lion 10.8
		1 )
			# This file is required because it will be used as source
			# to create the installer disk image.
			is_file "${installer_application_path}/Contents/SharedSupport/InstallESD.dmg" || return 1

			return 0
			;;

		# '2' - Installer application type for:
		# - OS X Mavericks 10.9
		# - OS X Yosemite 10.10
		# - OS X El Capitan 10.11
		2 )
			# Apple's command 'createinstallmedia' is required because
			# it will be used to create the installer disk image.
			is_file "${installer_application_path}/Contents/Resources/createinstallmedia" || return 1

			# All subsequent checks are the same as those performed by
			# Apple's command 'createinstallmedia' to determine if the
			# OS installer application is valid.
			is_file "${installer_application_path}/Contents/SharedSupport/InstallESD.dmg" || return 1
			is_file "${installer_application_path}/Contents/SharedSupport/OSInstall.mpkg" || return 1

			if is_file "${installer_application_path}/Contents/Info.plist"; then
				installer_application_short_version_string="$(get_installer_application_short_version_string "${installer_application_path}")" || return 1
				[[ "${installer_application_short_version_string}" =~ ${valid_installer_application_short_version_string_regex} ]] || return 1

				installer_application_identifier="$(get_installer_application_identifier "${installer_application_path}")" || return 1
				[[ "${installer_application_identifier}" =~ ${valid_installer_application_identifier_regex} ]] || return 1
			else
				return 1
			fi

			return 0
			;;

		# '3' - Installer application type for:
		# - macOS Sierra 10.12
		# - macOS High Sierra 10.13
		# - macOS Mojave 10.14
		3 )
			# Apple's command 'createinstallmedia' is required because
			# it will be used to create the installer disk image.
			is_file "${installer_application_path}/Contents/Resources/createinstallmedia" || return 1

			# This file is required because it contains the value for
			# 'LSMinimumSystemVersion', which determines the minimum
			# required macOS version for the installer application. The
			# value itself must be a valid macOS version number.
			if is_file "${installer_application_path}/Contents/Info.plist"; then
				installer_minimum_macos_version_string="$(get_installer_minimum_macos_version "${installer_application_path}")" || return 1
				[[ "${installer_minimum_macos_version_string}" =~ ${valid_installer_minimum_macos_version_string_regex} ]] || return 1
			else
				return 1
			fi

			# All subsequent checks are the same as those performed by
			# Apple's command 'createinstallmedia' to determine if the
			# OS installer application is valid.
			if is_file "${installer_application_path}/Contents/Info.plist"; then
				installer_application_short_version_string="$(get_installer_application_short_version_string "${installer_application_path}")" || return 1
				[[ "${installer_application_short_version_string}" =~ ${valid_installer_application_short_version_string_regex} ]] || return 1

				installer_application_identifier="$(get_installer_application_identifier "${installer_application_path}")" || return 1
				[[ "${installer_application_identifier}" =~ ${valid_installer_application_identifier_regex} ]] || return 1
			else
				return 1
			fi

			if is_file "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"; then
				system_image_url="$(get_system_image_url "${installer_application_path}")" || return 1
				is_file "${installer_application_path}/Contents/SharedSupport/${system_image_url}" || return 1
			else
				return 1
			fi

			return 0
			;;

	esac
	return 1
}

# ----------------------------------------------------------------------
# Checks if an operating system is macOS.
#
# Input:
# $1 - operating system name
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_macos() {
	local -r os_name="$1"

	is_not_empty "${os_name}" || return 1

	[[ "${os_name}" == "Darwin" ]]
}

is_valid_macos_version() {
	local -r macos_version="$1"
	local -r valid_macos_version_regex='^10\.[[:digit:]]+(\.[[:digit:]]+)?$'

	[[ "${macos_version}" =~ ${valid_macos_version_regex} ]]
}

is_unsupported_macos_minor_version() {
	local -r macos_minor_version="$1"

	is_array_item "${macos_minor_version}" "const_unsupported_macos_minor_versions"
}

is_supported_macos_minor_version() {
	local -r macos_minor_version="$1"

	is_array_item "${macos_minor_version}" "const_supported_macos_minor_versions"
}

is_supported_installer_application_display_name() {
	local -r installer_application_display_name="$1"

	is_array_item "${installer_application_display_name}" "const_supported_installer_application_display_names"
}

# ----------------------------------------------------------------------
# Checks if an item is contained in an array. The array is passed to the
# function by reference via its name.
#
# Input:
# $1 - item
# $2 - name of the array as string
#
# Output:
# none - returns with exit status zero if true
# ----------------------------------------------------------------------
is_array_item() {
	local -r item="$1"
	local -r array_name="$2[@]"
	local current_item

	for current_item in "${!array_name}"; do
		if [[ "${current_item}" == "${item}" ]]; then
			return 0
		fi
	done
	return 1
}

has_applicationpath_option() {
	local -r installer_application_path="$1"

	"${installer_application_path}/Contents/Resources/createinstallmedia" 2>&1 | grep --regexp="--applicationpath" &> /dev/null
}

# ----------------------------------------------------------------------
# Executes a PlistBuddy command on a property list file.
#
# Input:
# $1 - command to be executed by PlistBuddy
# $2 - property list file
#
# Output:
# output of PlistBuddy
# ----------------------------------------------------------------------
execute_plist_buddy_command() {
	local -r plist_command="$1"
	local -r plist_file="$2"

	is_not_empty "${plist_command}" || return 1
	is_not_empty "${plist_file}" || return 1

	/usr/libexec/PlistBuddy -c "${plist_command}" "${plist_file}" 2> /dev/null
}

# ----------------------------------------------------------------------
# Returns the name of the running operating system.
#
# Output:
# operating system name
# ----------------------------------------------------------------------
get_os_name() {
	local os_name

	os_name="$(uname -s 2> /dev/null)" || return 1

	echo "${os_name}"
	return 0
}

create_macos_name_and_version() {
	local -r -i macos_minor_version="${1:-0}"
	local -r -i macos_patch_version="${2:-0}"
	local -i largest_known_macos_minor_version="${#const_macos_names[@]}"
	local macos_name="macOS"
	local macos_version

	(( --largest_known_macos_minor_version ))

	if (( macos_minor_version < 0 || macos_patch_version < 0 )); then
		return 1
	fi

	if (( macos_minor_version <= largest_known_macos_minor_version )); then
		macos_name="${const_macos_names[${macos_minor_version}]}"
	fi

	if (( macos_patch_version > 0 )); then
		macos_version="10.${macos_minor_version}.${macos_patch_version}"
	else
		macos_version="10.${macos_minor_version}"
	fi

	echo "${macos_name} ${macos_version}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the value of an entry in a property list file.
#
# Input:
# $1 - entry
# $2 - property list file
#
# Output:
# value of the specified entry
# ----------------------------------------------------------------------
get_plist_value() {
	local -r entry="$1"
	local -r plist_file="$2"

	is_not_empty "${entry}" || return 1
	is_not_empty "${plist_file}" || return 1

	execute_plist_buddy_command "Print '${entry}'" "${plist_file}"
}

# ----------------------------------------------------------------------
# Returns the display name of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# display name of the installer application
# ----------------------------------------------------------------------
get_installer_application_display_name() {
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleDisplayName" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the short version string of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# short version string
# ----------------------------------------------------------------------
get_installer_application_short_version_string()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleShortVersionString" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the identifier of an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# identifier
# ----------------------------------------------------------------------
get_installer_application_identifier()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":CFBundleIdentifier" "${installer_application_path}/Contents/Info.plist"
}

# ----------------------------------------------------------------------
# Returns the URL of the system image within an installer application.
#
# Input:
# $1 - path to the installer application
#
# Output:
# URL of the system image
# ----------------------------------------------------------------------
get_system_image_url()
{
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":System Image Info:URL" "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"
}

# ----------------------------------------------------------------------
# Returns the absolute logical path to a file or directory.
#
# Input:
# $1 - absolute or relative path to a file or directory
#
# Output:
# absolute logical (i.e. not the physical) path to the file or directory
# ----------------------------------------------------------------------
get_absolute_logical_path() {
	local -r file_or_directory="$1"

	is_not_empty "${file_or_directory}" || return 1
	is_existing "${file_or_directory}" || return 1

	if is_directory "${file_or_directory}"; then
		echo "$(cd "${file_or_directory}"; pwd -L)"
	else
		if [[ "${file_or_directory}" == */* ]]; then
			echo "$(cd "${file_or_directory%/*}"; pwd -L)/${file_or_directory##*/}"
		else
			echo "$(pwd -L)/${file_or_directory}"
		fi
	fi
	return 0
}

# ----------------------------------------------------------------------
# Asks the user for consent on the command line. Any user input starting
# with 'y' or 'Y' will be treated as consent.
#
# Input:
# $1 - prompt to be displayed on the command line
#
# Output:
# none - returns with exit status zero if user gave his consent
# ----------------------------------------------------------------------
get_user_consent() {
	local -r prompt="$1"
	local input
	local -r yes_regex='^[yY].*$'

	echo -n "${prompt}"
	IFS= read -r input

	[[ "${input}" =~ ${yes_regex} ]]
}

get_example_installer_application_name() {
	local -r -i number_of_elements="${#const_supported_installer_application_display_names[@]}"
	local example_installer_application_name="${const_supported_installer_application_display_names[${number_of_elements}-1]}.app"
	local -i i

	for (( i = number_of_elements - 1; i >= 0; i-- )); do
		if is_valid_installer_application_path "/Applications/${const_supported_installer_application_display_names[${i}]}.app"; then
			example_installer_application_name="${const_supported_installer_application_display_names[${i}]}.app"
			break
		fi
	done

	echo "${example_installer_application_name}"
	return 0
}

# ----------------------------------------------------------------------
# Returns the type of an installer application. The type is determined
# by checking the presence of some files that are specific to the
# different installer types.
#
# The returned types are:
#
# '0' = Installer application type unknown
# '1' = Installer application type for:
#       - Mac OS X Lion 10.7
#       - OS X Mountain Lion 10.8
# '2' = Installer application type for:
#       - OS X Mavericks 10.9
#       - OS X Yosemite 10.10
#       - OS X El Capitan 10.11
# '3' = Installer application type for:
#       - macOS Sierra 10.12
#       - macOS High Sierra 10.13
#       - macOS Mojave 10.14
#
# Input:
# $1 - path to the installer application
#
# Output:
# type of the installer application
# ----------------------------------------------------------------------
get_installer_application_type()
{
	local -r installer_application_path="$1"
	local -i installer_application_type="0"

	is_not_empty "${installer_application_path}" || return 1

	if is_file "${installer_application_path}/Contents/Resources/createinstallmedia"; then
		if is_file "${installer_application_path}/Contents/SharedSupport/InstallInfo.plist"; then
			installer_application_type="3"
		else
			installer_application_type="2"
		fi
	else
		installer_application_type="1"
	fi

	echo "${installer_application_type}"
	return 0
}

get_installer_minimum_macos_version() {
	local -r installer_application_path="$1"

	is_not_empty "${installer_application_path}" || return 1

	get_plist_value ":LSMinimumSystemVersion" "${installer_application_path}/Contents/Info.plist"
}

create_install_media() {
	local -r installer_application_path="$1"
	local -r install_media_target_volname="$2"
	local -i exit_status

	is_not_empty "${installer_application_path}" || return 1
	is_not_empty "${install_media_target_volname}" || return 1

	if has_applicationpath_option "${installer_application_path}"; then
		script -k -q /dev/null "${installer_application_path}/Contents/Resources/createinstallmedia" --volume "/Volumes/${install_media_target_volname}" --applicationpath "${installer_application_path}" --nointeraction 2> /dev/null > >(parse_create_install_media)
		exit_status="$?"
	else
		script -k -q /dev/null "${installer_application_path}/Contents/Resources/createinstallmedia" --volume "/Volumes/${install_media_target_volname}" --nointeraction 2> /dev/null > >(parse_create_install_media)
		exit_status="$?"
	fi

	if script_createinstallmedia_was_canceled "${exit_status}"; then
		signal_handler
	fi

	return "${exit_status}"
}

script_createinstallmedia_was_canceled() {
	local -r exit_status="$1"

	is_not_empty "${exit_status}" || return 1

	[[ "${exit_status}" == "2" ]]
}

parse_create_install_media() {
	local char
	local line_buffer=""
	local line_blacklisted="false"
	local line_blacklist_item
	local -r -a line_blacklist=(
		'Erasing Disk: 0%...'
		'Erasing disk: 0%...'
		'Done.'
		'Install media now available at '
	)
	local text_buffer=""
	local text_blacklisted="false"
	local text_blacklist_item
	local -r -a text_blacklist=(
		' 10%...'
		' 30%...'
		' 50%...'
		' 70%...'
		' 90%...'
	)

	while IFS= read -r -n1 -d "" char; do
		line_buffer="${line_buffer}${char}"
		text_buffer="${text_buffer}${char}"

		if [[ "${char}" == $'\n' ]]; then
			if [[ ! "${line_blacklisted}" == "true" ]]; then
				echo -n "${text_buffer}"
			fi

			line_buffer=""
			text_buffer=""
		else
			line_blacklisted="false"
			for line_blacklist_item in "${line_blacklist[@]-}"; do
				is_not_empty "${line_blacklist_item}" || continue
				if [[ ("${#line_blacklist_item}" -gt "${#line_buffer}") && ("${line_blacklist_item}" =~ ^"${line_buffer}".*) ]]; then
					line_blacklisted="maybe"
				fi

				if [[ "${line_buffer}" =~ ^"${line_blacklist_item}".* ]]; then
					line_blacklisted="true"
					break
				fi
			done

			if [[ "${line_blacklisted}" == "false" ]]; then
				text_blacklisted="false"
				for text_blacklist_item in "${text_blacklist[@]-}"; do
					is_not_empty "${text_blacklist_item}" || continue
					if [[ ("${#text_blacklist_item}" -gt "${#text_buffer}") && ("${text_blacklist_item}" =~ ^"${text_buffer}".*) ]]; then
						text_blacklisted="maybe"
					fi

					if [[ "${text_buffer}" == "${text_blacklist_item}" ]]; then
						text_blacklisted="true"
						text_buffer=""
						break
					fi
				done

				if [[ "${text_blacklisted}" == "false" ]]; then
					echo -n "${text_buffer}"
					text_buffer=""
				fi
			fi
		fi
	done
}

create_iso_image() {
	local -r iso_source_image="$1"
	local -r iso_target_image="$2"
	local -r default_volume_name="$3"
	local -r typescript_file="${global_tmp_directory}/typescript_hdiutil_makehybrid"
	local -i exit_status

	is_not_empty "${iso_source_image}" || return 1
	is_not_empty "${iso_target_image}" || return 1
	is_not_empty "${default_volume_name}" || return 1

	is_existing "${iso_source_image}" || return 1

	script -k -q "${typescript_file}" hdiutil makehybrid -o "${iso_target_image}" "${iso_source_image}" -hfs -udf -default-volume-name "${default_volume_name}" 2> /dev/null > >(parse_create_iso_image)
	exit_status="$?"

	if script_hdiutil_makehybrid_was_canceled "${typescript_file}"; then
		signal_handler
	fi

	return "${exit_status}"
}

script_hdiutil_makehybrid_was_canceled() {
	local -r typescript_file="$1"

	is_not_empty "${typescript_file}" || return 1

	grep --regexp="canceling\.\.\." "${typescript_file}" &> /dev/null
}

parse_create_iso_image() {
	local char
	local line_buffer=""
	local line_blacklisted="false"
	local line_blacklist_item
	local -r -a line_blacklist=(
		'Creating hybrid image...'
		'hdiutil:'
	)
	local text_buffer=""
	local text_blacklisted="false"
	local text_blacklist_item
	local -r -a text_blacklist=(
		'canceling...'
	)
	local is_progress_line="false"
	local -r shell_columns=$(tput cols)
	local -r -i dots_count_max=$(( shell_columns - 2 ))
	local -i dots_count=0
	local -i percent
	local -i percent_step
	local -i -r -a percent_steps=("20" "40" "60" "80" "100")
	local -i last_percent=0
	local mute="false"
	local possible_empty_line="true"

	while IFS= read -r -n1 -d "" char; do
		if [[ "${mute}" == "true" ]]; then
			continue
		fi

		if [[ ("${char}" != $'\r') && ("${char}" != $'\n') ]]; then
			possible_empty_line="false"
		fi

		line_buffer="${line_buffer}${char}"
		text_buffer="${text_buffer}${char}"

		if [[ "${char}" == $'\n' ]]; then
			if [[ (! "${line_blacklisted}" == "true") && ("${possible_empty_line}" == "false") ]]; then
				echo -n "${text_buffer}"
				possible_empty_line="true"
			fi

			if [[ "${line_buffer}" =~ ^"${line_blacklist[0]}".* ]]; then
				echo -n "Creating ISO image: 0%..."
				is_progress_line="true"
			fi

			line_buffer=""
			text_buffer=""
		elif [[ ("${is_progress_line}" == "true") && ("${char}" == ".") ]]; then
			(( dots_count++ ))
			(( percent = (100 * dots_count) / dots_count_max ))

			for percent_step in "${percent_steps[@]}"; do
				if (( (last_percent < percent_step) && (percent >= percent_step) )); then
					echo -n " ${percent_step}%"
					if [[ "${percent_step}" != "100" ]]; then
						echo -n "..."
					fi
				fi
			done

			(( last_percent = percent ))

			line_buffer=""
			text_buffer=""
		else
			is_progress_line="false"
			line_blacklisted="false"
			for line_blacklist_item in "${line_blacklist[@]-}"; do
				is_not_empty "${line_blacklist_item}" || continue
				if [[ ("${#line_blacklist_item}" -gt "${#line_buffer}") && ("${line_blacklist_item}" =~ ^"${line_buffer}".*) ]]; then
					line_blacklisted="maybe"
				fi

				if [[ "${line_buffer}" =~ ^"${line_blacklist_item}".* ]]; then
					line_blacklisted="true"
					break
				fi
			done

			if [[ "${line_blacklisted}" == "false" ]]; then
				text_blacklisted="false"
				for text_blacklist_item in "${text_blacklist[@]-}"; do
					is_not_empty "${text_blacklist_item}" || continue
					if [[ ("${#text_blacklist_item}" -gt "${#text_buffer}") && ("${text_blacklist_item}" =~ ^"${text_buffer}".*) ]]; then
						text_blacklisted="maybe"
					fi

					if [[ "${text_buffer}" == "${text_blacklist_item}" ]]; then
						if [[ "${text_buffer}" == "${text_blacklist[0]}" ]]; then
							mute="true"
						fi
						text_blacklisted="true"
						text_buffer=""
						break
					fi
				done

				if [[ "${text_blacklisted}" == "false" ]]; then
					echo -n "${text_buffer}"
					text_buffer=""
				fi
			fi
		fi
	done
}

# ----------------------------------------------------------------------
# Issues an error message about an invalid option and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_invalid_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: unrecognized option \`${option}'"
	else
		echo_error "${const_script_name}: invalid option -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about a missing option parameter for an option
# and exits.
#
# Input:
# $1 - option (including leading '-')
# ----------------------------------------------------------------------
exit_missing_option_parameter_for_option() {
	local -r option="$1"

	if is_long_option "${option}"; then
		echo_error "${const_script_name}: option \`${option}' requires an argument"
	else
		echo_error "${const_script_name}: option requires an argument -- ${option:1}"
	fi

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about specifying an option parameter for a
# long option where no parameter is allowed and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_no_option_parameter_allowed_for_long_option(){
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' doesn't allow an argument"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message about an ambiguous specification for a long
# option and exits.
#
# Input:
# $1 - long option (including leading '-')
# ----------------------------------------------------------------------
exit_ambiguous_long_option() {
	local -r long_option="$1"

	echo_error "${const_script_name}: option \`${long_option}' is ambiguous"

	echo_error_usage
	exit 255
}

# ----------------------------------------------------------------------
# Issues an error message and exits.
#
# Input:
# $@ - optional error message(s)
# global_exit_with_error_exit_status - if set, used as exit status
# ----------------------------------------------------------------------
exit_with_error() {
	local -r -a error_messages=("$@")

	if (( ${#error_messages[@]} > 0 )); then
		echo_error "${error_messages[@]}"
	fi

	exit "${global_exit_with_error_exit_status:-1}"
}

# ======================================================================
# Main function
# ======================================================================

main() {
	set -o errexit
	set -o errtrace
	set -o nounset
	set -o pipefail

	trap "exit_handler" EXIT
	trap "signal_handler" SIGHUP SIGINT SIGQUIT SIGPIPE SIGTERM

	# ==================================================================
	# Check operating system requirements
	# ==================================================================

	local os_name

	local macos_version_string
	local -i -a macos_version
	local -i macos_major_version
	local -i macos_minor_version
	local -i macos_patch_version
	local -i macos_version_for_compare
	local macos_name_and_version

	os_name="$(get_os_name)" || exit_with_error "Couldn't get operating system name."

	if ! is_macos "${os_name}"; then
		echo_error "This tool must be run on macOS."
		exit 1
	fi

	macos_version_string="$(sw_vers -productVersion 2> /dev/null)" || exit_with_error "Couldn't get macOS version."
	IFS='.' read -r -a macos_version < <(echo "${macos_version_string}") || exit_with_error "Couldn't get macOS version."
	macos_major_version="${macos_version[0]:-0}"
	macos_minor_version="${macos_version[1]:-0}"
	macos_patch_version="${macos_version[2]:-0}"
	(( macos_version_for_compare = (macos_major_version * 10000) + (macos_minor_version * 100) + macos_patch_version ))

	if is_unsupported_macos_minor_version "${macos_minor_version}"; then
		macos_name_and_version="$(create_macos_name_and_version "${const_supported_macos_minor_versions[0]}")" || exit_with_error "Invalid macOS version."
		echo_error "This tool requires ${macos_name_and_version} or later."
		exit 1
	fi

	if ! is_supported_macos_minor_version "${macos_minor_version}"; then
		macos_name_and_version="$(create_macos_name_and_version "${macos_minor_version}" "${macos_patch_version}")" || exit_with_error "Invalid macOS version."
		echo_warning "This tool has not been tested on ${macos_name_and_version}."
	fi

	# ==================================================================
	# Parse command line arguments
	# ==================================================================

	unset option_applicationpath
	unset option_targetdirectory
	local option_nointeraction="false"

	local long_option
	local option_parameter

	# This script requires at least four arguments: Two options with one
	# option parameter each. However, this does not take into account
	# that one argument might already consist of an option and its
	# option parameter.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	if (( $# < 4 )); then
		echo_error_usage
		exit 0
	fi

	if ! is_root; then
		echo_error "This tool must be run as root."
		exit 249
	fi

	while [[ "${1+set}" == "set" ]]; do
		case "$1" in

			# Option '--applicationpath'
			-a* | --a* )
				long_option="--applicationpath"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_applicationpath="${option_parameter}"
				;;

			# Option '--targetdirectory'
			-t* | --t* )
				long_option="--targetdirectory"

				if is_option_including_option_parameter "$1"; then
					if is_long_option "$1"; then
						is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
						option_parameter="${1#--*=}"
					else
						option_parameter="${1#-?}"
					fi
					shift
				else
					if is_long_option "$1"; then
						is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					fi
					[[ "${2+set}" == "set" ]] || exit_missing_option_parameter_for_option "$1"
					option_parameter="$2"
					shift 2
				fi

				option_targetdirectory="${option_parameter}"
				;;

			# Option '--nointeraction'
			-n* | --n* )
				long_option="--nointeraction"

				if is_long_option_including_option_parameter "$1"; then
					is_valid_long_option "${1%%=*}" "${long_option}" || exit_invalid_option "$1"
					exit_no_option_parameter_allowed_for_long_option "${1%%=*}"
				elif is_long_option "$1"; then
					is_valid_long_option "$1" "${long_option}" || exit_invalid_option "$1"
					shift
				elif is_short_options_combination "$1"; then
					set -- "-${1:2}" "${@:2}"
				else
					shift
				fi

				option_nointeraction="true"
				;;

			# End of options
			-- )
				shift
				break
				;;

			# Ambiguous long option
			--=* )
				exit_ambiguous_long_option "${1%%=*}"
				;;

			# Invalid short or long option
			-[^-]* | --?* )
				exit_invalid_option "$1"
				;;

			# Non-option argument or single '-'
			* )
				shift
				;;

		esac
	done

	# ==================================================================
	# Verify command line options
	# ==================================================================

	if [[ "${option_applicationpath+set}" != "set" || "${option_targetdirectory+set}" != "set" ]]; then
		echo_error "You must specify both the target directory and install application path."
		exit 255
	fi

	if ! is_valid_target_directory_path "${option_targetdirectory}"; then
		echo_error "${option_targetdirectory} is not a valid target directory."
		exit 254
	fi

	if ! is_valid_installer_application_path "${option_applicationpath}"; then
		echo_error "${option_applicationpath} does not appear to be a valid OS installer application."
		exit 253
	fi

	# ==================================================================
	# Initialization
	# ==================================================================

	local installer_application_path
	local target_directory_path
	local installer_application_display_name
	local -i installer_application_type
	local iso_target_image
	local random_string

	installer_application_path="$(get_absolute_logical_path "${option_applicationpath}")" || exit_with_error "Couldn't get absolute path for ${option_applicationpath}."
	target_directory_path="$(get_absolute_logical_path "${option_targetdirectory}")" || exit_with_error "Couldn't get absolute path for ${option_targetdirectory}."

	installer_application_display_name="$(get_installer_application_display_name "${installer_application_path}")" || exit_with_error "Couldn't get installer application display name."
	installer_application_type="$(get_installer_application_type "${installer_application_path}")" || exit_with_error "Couldn't get installer application type."
	iso_target_image="${target_directory_path}/${installer_application_display_name}.iso"

	global_tmp_directory="$(mktemp -d -t "${const_script_name}")" || exit_with_error "Failed to create temporary directory."
	random_string="${global_tmp_directory##*.}"

	# ==================================================================
	# Check installer application requirements
	# ==================================================================

	local installer_minimum_macos_version_string
	local -i -a installer_minimum_macos_version
	local -i installer_minimum_macos_major_version
	local -i installer_minimum_macos_minor_version
	local -i installer_minimum_macos_patch_version
	local -i installer_minimum_macos_version_for_compare

	if ! is_supported_installer_application_display_name "${installer_application_display_name}"; then
		echo_warning "${installer_application_display_name} is not a supported installer."
	fi

	if [[ "${installer_application_type}" == "3" ]]; then
		installer_minimum_macos_version_string="$(get_installer_minimum_macos_version "${installer_application_path}")" || exit_with_error "Couldn't get minimum macOS version for installer application."
		IFS='.' read -r -a installer_minimum_macos_version < <(echo "${installer_minimum_macos_version_string}") || exit_with_error "Couldn't get minimum macOS version for installer application."
		installer_minimum_macos_major_version="${installer_minimum_macos_version[0]:-0}"
		installer_minimum_macos_minor_version="${installer_minimum_macos_version[1]:-0}"
		installer_minimum_macos_patch_version="${installer_minimum_macos_version[2]:-0}"
		(( installer_minimum_macos_version_for_compare = (installer_minimum_macos_major_version * 10000) + (installer_minimum_macos_minor_version * 100) + installer_minimum_macos_patch_version ))

		if (( installer_minimum_macos_version_for_compare > macos_version_for_compare )); then
			macos_name_and_version="$(create_macos_name_and_version "${installer_minimum_macos_minor_version}" "${installer_minimum_macos_patch_version}")" || exit_with_error "Invalid macOS version."
			echo_error "You need ${macos_name_and_version} or later to create an ISO image from this installer application."
			exit 1
		fi
	fi

	# ==================================================================
	# Perform required user interactions
	# ==================================================================

	local type_of_existing_target

	if is_existing "${iso_target_image}"; then
		if is_file "${iso_target_image}"; then
			type_of_existing_target="file"
		else
			type_of_existing_target="directory"
		fi
		if [[ ! "${option_nointeraction}" == "true" ]]; then
			echo "Ready to start."
			echo "To continue we need to delete the ${type_of_existing_target} ${iso_target_image}."
			if ! get_user_consent "If you wish to continue type (Y) then press return: "; then
				echo "Operation canceled."
				exit 0
			fi
		fi

		rm -rf "${iso_target_image}" &> /dev/null || exit_with_error "Failed to delete the ${type_of_existing_target} ${iso_target_image}."
	fi

	# Once the script has reached this point of execution, it will
	# return with exit status zero in case of an error and issue an exit
	# message before exiting.
	#
	# NOTE: This behavior is intended to replicate the behavior of
	# Apple's command 'createinstallmedia' for creation of a bootable
	# installer USB flash drive or other volume.
	global_exit_with_error_exit_status="0"
	global_exit_message="Done."

	# ==================================================================
	# Create source image for ISO image
	# ==================================================================

	local iso_source_image
	local install_media_target_image
	local install_media_target_volname

	case "${installer_application_type}" in

		# '1' - Installer application type for:
		# - Mac OS X Lion 10.7
		# - OS X Mountain Lion 10.8
		1 )
			iso_source_image="${installer_application_path}/Contents/SharedSupport/InstallESD.dmg"
			;;

		# '2' - Installer application type for:
		# - OS X Mavericks 10.9
		# - OS X Yosemite 10.10
		# - OS X El Capitan 10.11
		2 )
			;;

		# '3' - Installer application type for:
		# - macOS Sierra 10.12
		# - macOS High Sierra 10.13
		# - macOS Mojave 10.14
		3 )
			echo "Creating disk image..."
			install_media_target_image="${global_tmp_directory}/InstallMedia.sparseimage"
			install_media_target_volname="InstallMedia.${random_string}"
			hdiutil create -size 12g "${install_media_target_image}" -type SPARSE -fs HFS+J -volname "${install_media_target_volname}" &> /dev/null || exit_with_error "Failed to create disk image."
			global_install_media_device_node="$(hdiutil attach "${install_media_target_image}" -nobrowse -noverify 2> /dev/null | (IFS=$' \t\n' read -r device_node remainder; echo "${device_node}"))" || exit_with_error "Couldn't mount disk image."
			echo "Create complete."

			create_install_media "${installer_application_path}" "${install_media_target_volname}" || exit_with_error "Failed to create install media."

			hdiutil detach "${global_install_media_device_node}" -force &> /dev/null || exit_with_error "Couldn't unmount disk image."
			unset global_install_media_device_node

			iso_source_image="${install_media_target_image}"
			;;

	esac

	# ==================================================================
	# Create ISO image
	# ==================================================================

	global_incomplete_iso_target_image="${iso_target_image}"
	create_iso_image "${iso_source_image}" "${iso_target_image}" "${installer_application_display_name}" || exit_with_error "Failed to create ISO image."
	unset global_incomplete_iso_target_image

	exit 0
}

main "$@"
